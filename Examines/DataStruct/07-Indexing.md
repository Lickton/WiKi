# 07 - 查找

## B/B+树

> (2023 - T7) 下面关于非空 B 树的说法正确的是  
1\. 插入操作可能会增加树的高度 2. 删除节点一定会改变叶节点  
3\. B 树查找一定会找到叶节点 4. 插入节点最终一定会在叶节点上

解答：

**B 树的定义**

对于一个$m$阶的 B 树
- 每一个节点有$m$棵子树
- 每一个非叶子节点（除根节点）最少有$\lceil\frac{m}{2}\rceil$个子节点
- 如果根节点不是叶子节点，那么它至少有两个子节点
- 有$k$个子节点的非叶子节点拥有$k-1$个键
- 所有叶子节点都在同一层

每一个内部节点的键将节点的子树分开。例如，如果一个内部节点有3个子节点（子树），那么它就必须有两个键$a_1$和$a_2$。左边子树的所有值都必须小于$a_1$，中间子树的所有值必须在$a_1$和$a_2$之间，右边子树的所有值多必须大于$a_2$。

**内部节点**

内部节点是除了叶子节点和根节点之外的所有节点。它们通常被表示为一组有序的元素和指向子节点的指针。每一个内部节点拥有最多$U$个，最少$L$个子节点。元素的数量总是比子节点指针的数量少一（$L-1\leq N \leq U-1$）。$U$必须等于$2L$或$2L-1$；因此，每一个内部节点都至少是半满的。$U$和$L$之间的关系意味着两个半满的节点可以合并成一个合法的节点，一个全满的节点可以被分裂成两个合法的节点（如果父节点有空间容纳移来的一个元素）。这使得在 B 树中删除或插入新的值可以调整树来保持 B 树的性质。

**根节点**

根节点拥有的子节点数量的上限和内部节点相同，但没有下限。例如，当整个树的元素数量小于$L-1$时，根节点是唯一节点并且没有任何子节点


**B 树的插入**  

所有的插入都是从根节点开始。要插入一个元素，首先搜索这颗树，找到新元素应该被添加到的对应节点。将新元素插入到这一节点中的步骤如下：

1. 如果节点拥有的元素数量小于最大值，那么有空间容纳新的元素。将新元素插入到这一节点，且保持元素有序
2. 若这一节点已经满了，则将它平均地分裂成两个节点
    1. 从该节点的原有元素和新元素中选择出中位数
    2. 小于这一中位数的元素放入左边节点，大于这一中位数的元素放入右边节点，中位数作为分隔值
    3. 分隔值被插入父节点，这可能会导致父节点分裂，分裂父节点时又可能会使它的父节点分裂，以此类推。若没有父节点（根节点），见创建一个新的根节点，这增加了树的高度

若分裂一直上升至根节点，那么一个新的根节点就会被创建，它又一个分隔值和两个子节点。这就是根节点并不像内部节点一样有最少子节点数量限制的原因。每个节点中元素的最大数量是$U-1$。当一个节点分裂时，一个元素被移动到它的父节点，但一个新的元素被增加进来了。所以最大元素数量$U-1$必须能够被分成两个合法的节点。
- 如果$U-1$是奇数，那么$U=2L$，总共有$2L-1$个元素，一个新的节点有$L-1$个元素，另一个有$L$个元素，都是合法的节点
- 如果$U-1$是偶数，那么$U=2L-1$，总共有$2L-2$个元素。一半是$L-1$，正好是节点允许的最小元素数量

在 [Data Structure Visualizatrions](https://www.cs.usfca.edu/~galles/visualization/BTree.html) 中模拟 B 树插入操作：
- 当$Max.Degree=3$时，$U=3,L=2$，满足$U=2L-1$。先后插入$24,35,30,14$，若此时要插入$20$，则叶子节点$[14\ \ 24]$将满，总共有$2L-2=2$个元素。分裂后每个子树都有$L-1=1$个元素，左新节点$[14]$，右新节点$[20]$
- 当$Max.Degree=4$时，$U=4,L=2$，满足$U=2L$。先后插入$24,35,37,26,11,20$，若此时要插入$23$，则叶子节点$[11\ 20\ 24]$将满，总共有$2L-1=3$个元素。分裂后，左新节点有$L-1=1$个元素$[11]$，右新节点有$L=2$个新元素$[23\ 24]$，都是合法节点

**B 树的删除**

常用的删除策略有两种

1. 定位并删除元素，然后调整树使它满足约束条件
2. 从上到下处理这颗树，在进入一个节点之前，调整树使得之后一旦遇到了要删除的键，它可以被直接删除而不需要再进行调整

下面说明的算法使用了前一种策略。  
删除一个元素会有以下两种特殊情况
1. 这个元素用于分隔一个内部节点的子结点
2. 删除元素会导致它所在的节点的元素或节点数量小于最低值

**删除叶子节点中的元素**

1. 搜索要删除的元素
2. 如果它在叶子节点，那么将它从中删除
3. 若发生了下溢出，按照后面“删除后重新平衡”部分的描述重新调整树

**删除内部节点的元素**   
内部节点中的每一个元素都作为分隔两颗子树的分隔值（特殊情况1），因此需要重新划分。值得注意的是左子树中最大的元素仍然小于分隔值。同样的，右子树中的最小值仍然大于分隔值。这两个元素都在叶子节点中，并且任何一个都可以作为两颗子树的新分隔值，算法描述如下

1. 选择一个新的分隔符（左子树中最大元素或右子树中最小的元素），将它从叶子节点中移除，替换被删除的元素作为新的分隔值
2. 步骤1删除了一个叶子节点中的元素，如果这个叶子节点拥有的元素数量小于最低要求，那么从这一叶子节点开始重新进行平衡

**删除后的重新平衡**  
重新平衡从叶子节点开始向根节点进行，直到树重新平衡。如果删除节点中的一个元素使该节点的元素数量低于最小值，那么一些元素必须被重新分配。通常，移动一个元素数量大于最小值($L-1$)的兄弟节点中的元素。如果兄弟节点都没有多余的元素，那么缺少元素的节点就必须要和他的兄弟**合并**。合并可能会导致父节点失去分隔值，所以父节点可能缺少元素并需要重新平衡。合并和重新平衡可能一直进行到根节点，根节点变成唯一缺少元素的节点。重新平衡树的算法如下
- 如果缺少元素节点的右兄弟存在并且拥有多于的元素($N>L-1$)，那么向左旋转  
    1. 将父节点的分隔值复制到缺少元素节点的最后（分隔值被移动下来；缺少元素的节点现在有最小数量的元素）
    2. 将父节点的分隔值替换为右兄弟的第一个元素（右兄弟失去了一个节点但仍拥有最小数量的元素($N\geq L-1$) ）
    3. 此时树右重新平衡
- 否则，若缺少元素节点的左兄弟存在且拥有多余的元素，那么向右旋转  
    1. 将父节点的分隔值复制到缺少元素节点的第一个节点（分隔值被移动下来；缺少元素的节点现在拥有最小数量的元素）
    2. 将父节点的分隔值替换为左兄弟的最后一个元素（左兄弟失去了一个节点但仍然拥有最小数量的元素）
    3. 此时树又重新平衡
- 否则，如果它的两个直接兄弟节点都只有最小数量的元素，那么将它与一个直接兄弟节点以及父节点中它们的分隔值合并
    1. 将分隔值复制到左边的节点（左边的节点可以是缺少元素($N<L-1$)的节点或者拥有最小数量($N=L-1$)元素的兄弟节点）
    2. 将右边节点中所有的元素移动到左边节点（左边节点现在拥有最大数量的元素($N_{max}\leq2L-2< U$)，右边节点为空）
    3. 将父节点中的分隔值和空的右子树移除（父节点失去了一个元素）
        - 如果父节点是根节点并且没有元素了，那么释放它并且让合并之后的节点成为新的根节点（树的深度减小）
        - 否则，如果父节点的元素数量小于最小值，重新平衡父节点


在捋顺 B 树的一系列操作之后，回头来看看题目中的选项

> 1. 插入操作可能会增加树的高度

是可能的

> 2. 删除节点一定会改变叶节点

删除操作分为两种情况  
1. 若删除的是叶子节点，那么叶子节点必定被改变了
2. 若删除的是第$i$层内部节点，由于内部节点的每一个元素都分隔第$i+1$层子节点，直至叶子节点，那么叶子节点最终也会被改变

所以删除节点一定会改变叶节点

> 3. B 树查找一定会查找到叶节点

B 树内部节点也是元素，而 B+ 树内部节点不保存元素

> 4. 插入节点最终一定在叶节点上

向 B 树中插入元素时，先找到节点
- 若该节点有足够的空间，那么就可以直接插入这一节点并保持有序，此时是插入到叶节点中
- 若该节点没有足够的空间，那么需要从该节点的元素和新元素中选取中间值作为分隔元素，小于分隔元素的元素分去左子树，大于分隔值的元素被分去右子树，而分隔值会被插入到父节点，而该被插入的新值就可能是分隔值，此时并不是被插入到叶子节点

综上所述，仅`1 2`正确

## 散列表

> (2023 - T9) 现有长度为$5$，初始为空的散列表HT，散列表函数$H(k)=(k+4)\%5$用线性探查再散列法解决冲突。若将关键字序列$20,22,12,25$依次插入HT中，然后删除关键字$25$，则在HT中查找失败的平均查找长度为________

按题意完成后的散列表为

|0|1|2|3|4|
|-----|--|--|--|--|
|~~25~~|22|12||20|

- 查找成功的平均查找长度为$ASL_{Success}=\frac{\sum k_i}{n}=\frac{1+2+1}{3}=4/3$，其中$k_i$为查找映射为$i$的值成功（既然是查找成功，那么要查找的值必须在散列表内，故除以的是表内元素个数）的比较次数
- 查找失败的平均查找长度为$ASL_{Fail}=\frac{\sum k_i}{M}=\frac{1+3+2+1+2}{5}=1.8$，其中$k_i$是查找映射为$i$的值失败（由于要求查找失败，则对于$0\cdots M$每一个位置查找失败都需要考虑）所需要的比较次数
