# 图

## 最小生成树、最短路

> 已知无向连通图 G 中各边的权值均为1，下列算法中，一定能求出图 G 中从某顶点到其他各个顶点最短路径的是：  
1\. 普利姆算法 2. 克鲁斯卡尔算法 3. 广度优先遍历BFS

解答：  

- 最小生成树
    - Prim 算法：从任意一个顶点开始，选取与当前已添加顶点集合最近的点加入集合构建最小生成树
    - Kruskal 算法：每次选取权值最小的边，若该边两端点不属于同一集合，则合并，以此构建最小生成树
- 最短路
    - Dijkstra 算法：单源最短路，每次在未确定的点中选取距离最短的路径，并用源点到该点的距离加上该点到其他顶点的距离，与原本源点到其他顶点的距离比较，取最小值更新，重复 $$n$$ 遍则得到了最短路径
    - Floyd 算法：多源最短路算法，要寻找从$$i$$到$$j$$的最短路，要么是由$$i$$直接到$$j$$，要么经由若干个$$k$$到达$$j$$，即$$dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])$$
    - Bellman-Ford 算法：求含负权图的单源最短路算法，dijkstra不能解决负权边是因为 dijkstra要求每个点被确定后$$st[j] = true$$，$$dist[j]$$就是最短距离了，之后就不能再被更新了，而如果有负权边的话，那已经确定的点的$$dist[j]$$不一定是最短了

虽然最小生成树和最短路径都涉及到图的路径和权重，但它们的目标和应用场景不同。

- 最小生成树是为了找到连接整个拓扑图的最小权重路径，而不关心特定顶点之间的最短路径。它主要关注整个图的拓扑结构和连通性。
- 最短路径算法则是为了找到特定两个顶点之间的最短路径，而不一定关心图中的其他顶点和边。它集中于解决从起始顶点到目标顶点的最短路径问题。

因此，最小生成树不能保证任意两点之间的最短路径，因为它的目标是连通整个图并使总权重最小，而不是找到特定两点之间的最短路径。要找到任意两点之间的最短路径，需要使用专门设计的最短路径算法。

因此，仅 BFS 满足题目要求。
